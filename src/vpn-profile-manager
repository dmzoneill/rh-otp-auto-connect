#!/usr/bin/env python3
"""
VPN Profile Manager - Manage Red Hat VPN NetworkManager profiles

Commands:
  list              List all configured VPN profiles
  generate [id]     Generate .nmconnection files for profiles
  install [id]      Install profile(s) to NetworkManager
  install-all       Install all profiles
  connect <id>      Connect to a specific VPN profile
  disconnect        Disconnect active VPN
  status            Show VPN connection status
  clean             Remove all Red Hat VPN profiles from NetworkManager
  clean-duplicates  Remove duplicate profiles (keeps first of each ID)
"""

import argparse
import os
import re
import subprocess
import sys
import uuid
from pathlib import Path

import gnupg
import yaml
from jinja2 import Environment, FileSystemLoader

# Configuration
PROJECT_DIR = Path(__file__).parent
PROFILES_DIR = PROJECT_DIR / "vpn-profiles"
PROFILES_FILE = PROFILES_DIR / "profiles.yaml"
TEMPLATE_DIR = PROFILES_DIR / "templates"
GENERATED_DIR = PROFILES_DIR / "generated"
NM_CONNECTIONS_DIR = Path("/etc/NetworkManager/system-connections")


def get_from_store(item):
    """Retrieve value from password store using gnupg."""
    gpg = gnupg.GPG()
    pass_store_path = os.path.expanduser("~/.password-store")
    secret_file_path = os.path.join(pass_store_path, "redhat.com/" + item + ".gpg")

    if not os.path.exists(secret_file_path):
        print(f"Error: {secret_file_path} does not exist.")
        return None

    try:
        with open(secret_file_path, "rb") as f:
            decrypted_data = gpg.decrypt_file(f)
            if decrypted_data.ok:
                return decrypted_data.data.decode("utf-8").strip()
            else:
                # Fall back to using pass command
                result = subprocess.run(
                    ["pass", "show", f"redhat.com/{item}"],
                    capture_output=True,
                    text=True
                )
                if result.returncode == 0:
                    return result.stdout.strip()
                else:
                    print(f"Error retrieving {item} from password store")
                    return None
    except Exception as e:
        print(f"Error retrieving password: {e}")
        return None


def load_profiles():
    """Load profiles from profiles.yaml"""
    if not PROFILES_FILE.exists():
        print(f"Error: {PROFILES_FILE} not found")
        print("Run: cd vpn-profiles && python3 scan-profiles.py")
        sys.exit(1)

    with open(PROFILES_FILE) as f:
        config = yaml.safe_load(f)

    return config


def list_profiles(args):
    """List all configured VPN profiles."""
    config = load_profiles()
    profiles = config['profiles']

    print(f"Found {len(profiles)} VPN profiles:\n")
    print(f"{'ID':<15} {'Name':<40} {'Remote':<35} {'Proto'}")
    print("=" * 100)

    for profile in profiles:
        profile_id = profile['id']
        name = profile['name']
        remote = profile['remote']
        proto = "TCP" if profile.get('proto_tcp', config['default_settings'].get('proto_tcp')) else "UDP"

        print(f"{profile_id:<15} {name:<40} {remote:<35} {proto}")


def generate_profiles(args):
    """Generate .nmconnection files from profiles.yaml."""
    config = load_profiles()
    defaults = config['default_settings']
    profiles = config['profiles']

    # Get username from pass
    username = get_from_store("username")
    if not username:
        print("Error: Could not retrieve username from password store")
        sys.exit(1)

    # Set up Jinja2 environment
    env = Environment(loader=FileSystemLoader(TEMPLATE_DIR))
    template = env.get_template('redhat-vpn.j2')

    # Create generated directory
    GENERATED_DIR.mkdir(parents=True, exist_ok=True)

    # Filter profiles if ID specified
    if args.id:
        profiles = [p for p in profiles if p['id'].upper() == args.id.upper()]
        if not profiles:
            print(f"Error: Profile '{args.id}' not found")
            sys.exit(1)

    print(f"Generating {len(profiles)} profile(s)...")

    for profile in profiles:
        # Merge defaults with profile-specific settings
        context = defaults.copy()
        context.update(profile)

        # Replace project_dir placeholder in ca path
        context['ca'] = context['ca'].replace('{{project_dir}}', str(PROJECT_DIR))

        # Add username
        context['username'] = username

        # Generate UUID if not present
        if 'uuid' not in context or not context['uuid']:
            context['uuid'] = str(uuid.uuid4())

        # Render template
        content = template.render(**context)

        # Write to generated directory
        # Use UUID for filename to ensure uniqueness
        filename = f"{context['id']}_{context['uuid']}.nmconnection"
        output_path = GENERATED_DIR / filename

        output_path.write_text(content)
        print(f"Generated: {filename}")

    print(f"\nGenerated files are in: {GENERATED_DIR}")


def install_profiles(args):
    """Install profile(s) to NetworkManager."""
    config = load_profiles()

    # Generate profiles first
    generate_profiles(args)

    # Get list of generated files
    if args.id:
        pattern = f"{args.id.upper()}_*.nmconnection"
    else:
        pattern = "*.nmconnection"

    generated_files = list(GENERATED_DIR.glob(pattern))

    if not generated_files:
        print("No profiles to install")
        sys.exit(0)

    print(f"\nInstalling {len(generated_files)} profile(s) to NetworkManager...")

    for gen_file in generated_files:
        dest_file = NM_CONNECTIONS_DIR / gen_file.name

        # Copy file to NetworkManager
        try:
            subprocess.run(
                ["sudo", "cp", str(gen_file), str(dest_file)],
                check=True
            )
            # Set proper permissions
            subprocess.run(
                ["sudo", "chmod", "600", str(dest_file)],
                check=True
            )
            subprocess.run(
                ["sudo", "chown", "root:root", str(dest_file)],
                check=True
            )
            print(f"Installed: {gen_file.name}")
        except subprocess.CalledProcessError as e:
            print(f"Error installing {gen_file.name}: {e}")

    # Reload NetworkManager
    print("\nReloading NetworkManager...")
    subprocess.run(["sudo", "nmcli", "connection", "reload"])
    print("Done!")


def connect_vpn(args):
    """Connect to a specific VPN profile."""
    if not args.id:
        print("Error: Profile ID required")
        print("Usage: vpn-profile-manager connect <id>")
        sys.exit(1)

    config = load_profiles()
    profiles = [p for p in config['profiles'] if p['id'].upper() == args.id.upper()]

    if not profiles:
        print(f"Error: Profile '{args.id}' not found")
        sys.exit(1)

    # Use the first matching profile's UUID or name
    profile = profiles[0]
    profile_uuid = profile.get('uuid')
    profile_name = profile.get('name')

    print(f"Connecting to {profile_name}...")

    # Try to connect using UUID first, fall back to name
    if profile_uuid:
        result = subprocess.run(
            ["nmcli", "connection", "up", "uuid", profile_uuid],
            capture_output=True,
            text=True
        )
    else:
        result = subprocess.run(
            ["nmcli", "connection", "up", "id", profile_name],
            capture_output=True,
            text=True
        )

    if result.returncode == 0:
        print(f"Connected to {profile_name}")
    else:
        print(f"Failed to connect: {result.stderr}")
        sys.exit(1)


def disconnect_vpn(args):
    """Disconnect active VPN."""
    # Find active VPN connections
    result = subprocess.run(
        ["nmcli", "connection", "show", "--active"],
        capture_output=True,
        text=True
    )

    vpn_connections = []
    for line in result.stdout.splitlines():
        if 'vpn' in line.lower() and 'redhat.com' in line.lower():
            parts = line.split()
            if len(parts) >= 2:
                conn_name = ' '.join(parts[:-3])  # Name is everything except last 3 fields
                vpn_connections.append(conn_name)

    if not vpn_connections:
        print("No active Red Hat VPN connections")
        return

    print(f"Disconnecting {len(vpn_connections)} VPN connection(s)...")
    for conn in vpn_connections:
        subprocess.run(["nmcli", "connection", "down", "id", conn])
        print(f"Disconnected: {conn}")


def vpn_status(args):
    """Show VPN connection status."""
    result = subprocess.run(
        ["nmcli", "connection", "show", "--active"],
        capture_output=True,
        text=True
    )

    vpn_found = False
    print("Active VPN Connections:")
    print("=" * 80)

    for line in result.stdout.splitlines():
        if 'vpn' in line.lower():
            print(line)
            vpn_found = True

    if not vpn_found:
        print("No active VPN connections")


def clean_profiles(args):
    """Remove all Red Hat VPN profiles from NetworkManager."""
    print("Scanning for Red Hat VPN profiles in NetworkManager...")

    # Find all Red Hat VPN profiles
    rh_profiles = []
    for conn_file in NM_CONNECTIONS_DIR.glob("*.nmconnection"):
        try:
            content = subprocess.run(
                ["sudo", "cat", str(conn_file)],
                capture_output=True,
                text=True,
                check=True
            ).stdout

            if 'redhat.com' in content:
                rh_profiles.append(conn_file)
        except subprocess.CalledProcessError:
            continue

    if not rh_profiles:
        print("No Red Hat VPN profiles found")
        return

    print(f"\nFound {len(rh_profiles)} Red Hat VPN profile(s):")
    for profile in rh_profiles:
        print(f"  - {profile.name}")

    if not args.yes:
        response = input(f"\nRemove all {len(rh_profiles)} profiles? [y/N]: ")
        if response.lower() != 'y':
            print("Cancelled")
            return

    print("\nRemoving profiles...")
    for profile in rh_profiles:
        try:
            subprocess.run(["sudo", "rm", str(profile)], check=True)
            print(f"Removed: {profile.name}")
        except subprocess.CalledProcessError as e:
            print(f"Error removing {profile.name}: {e}")

    print("\nReloading NetworkManager...")
    subprocess.run(["sudo", "nmcli", "connection", "reload"])
    print("Done!")


def clean_duplicates(args):
    """Remove duplicate profiles (keeps first of each ID)."""
    config = load_profiles()

    # Group profiles by ID
    profiles_by_id = {}
    for profile in config['profiles']:
        profile_id = profile['id']
        if profile_id not in profiles_by_id:
            profiles_by_id[profile_id] = []
        profiles_by_id[profile_id].append(profile)

    # Find duplicates
    duplicates = {k: v[1:] for k, v in profiles_by_id.items() if len(v) > 1}

    if not duplicates:
        print("No duplicate profiles found")
        return

    print(f"Found duplicate profiles:")
    for profile_id, dups in duplicates.items():
        print(f"\n{profile_id}: {len(dups) + 1} total (will keep first, remove {len(dups)})")
        for dup in dups:
            print(f"  - {dup['name']} (UUID: {dup.get('uuid', 'N/A')})")

    if not args.yes:
        response = input(f"\nRemove duplicates? [y/N]: ")
        if response.lower() != 'y':
            print("Cancelled")
            return

    print("\nRemoving duplicate profiles from NetworkManager...")
    removed_count = 0

    for profile_id, dups in duplicates.items():
        for dup in dups:
            dup_uuid = dup.get('uuid')
            if dup_uuid:
                # Find and remove the connection file
                for conn_file in NM_CONNECTIONS_DIR.glob("*.nmconnection"):
                    try:
                        content = subprocess.run(
                            ["sudo", "cat", str(conn_file)],
                            capture_output=True,
                            text=True,
                            check=True
                        ).stdout

                        if f"uuid={dup_uuid}" in content:
                            subprocess.run(["sudo", "rm", str(conn_file)], check=True)
                            print(f"Removed: {dup['name']}")
                            removed_count += 1
                            break
                    except subprocess.CalledProcessError:
                        continue

    print(f"\nRemoved {removed_count} duplicate profile(s)")
    print("Reloading NetworkManager...")
    subprocess.run(["sudo", "nmcli", "connection", "reload"])
    print("Done!")


def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Manage Red Hat VPN NetworkManager profiles",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    subparsers = parser.add_subparsers(dest='command', help='Command to execute')

    # list command
    subparsers.add_parser('list', help='List all configured VPN profiles')

    # generate command
    gen_parser = subparsers.add_parser('generate', help='Generate .nmconnection files')
    gen_parser.add_argument('id', nargs='?', help='Profile ID to generate (optional)')

    # install command
    install_parser = subparsers.add_parser('install', help='Install profile to NetworkManager')
    install_parser.add_argument('id', nargs='?', help='Profile ID to install (optional)')

    # install-all command
    subparsers.add_parser('install-all', help='Install all profiles')

    # connect command
    connect_parser = subparsers.add_parser('connect', help='Connect to VPN profile')
    connect_parser.add_argument('id', help='Profile ID to connect to')

    # disconnect command
    subparsers.add_parser('disconnect', help='Disconnect active VPN')

    # status command
    subparsers.add_parser('status', help='Show VPN connection status')

    # clean command
    clean_parser = subparsers.add_parser('clean', help='Remove all Red Hat VPN profiles')
    clean_parser.add_argument('-y', '--yes', action='store_true', help='Skip confirmation')

    # clean-duplicates command
    clean_dup_parser = subparsers.add_parser('clean-duplicates', help='Remove duplicate profiles')
    clean_dup_parser.add_argument('-y', '--yes', action='store_true', help='Skip confirmation')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    # Execute command
    commands = {
        'list': list_profiles,
        'generate': generate_profiles,
        'install': install_profiles,
        'install-all': install_profiles,
        'connect': connect_vpn,
        'disconnect': disconnect_vpn,
        'status': vpn_status,
        'clean': clean_profiles,
        'clean-duplicates': clean_duplicates,
    }

    # For install-all, set id to None
    if args.command == 'install-all':
        args.id = None

    command_func = commands.get(args.command)
    if command_func:
        command_func(args)
    else:
        print(f"Unknown command: {args.command}")
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
