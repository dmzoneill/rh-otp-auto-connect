#!/usr/bin/env python3

import argparse
import json
import os
import re
import shlex
import shutil
import signal
import stat
import subprocess
import sys
import time
import urllib.request
import zipfile

import requests
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait

script_dir = os.path.dirname(os.path.realpath(__file__))

# Load configuration from rhtoken.json
config = None
chrome_driver_dir = None
chrome_driver_location = None
profile_location = None
chrome_binary = None

driver = None
login_process = None


def cleanup(signum=None, frame=None):
    print("\n[INFO] Cleaning up before exit...")

    if driver:
        try:
            driver.quit()
            print("[INFO] WebDriver closed successfully.")
        except Exception as e:
            print(f"[WARN] WebDriver cleanup failed: {e}")

    if login_process:
        try:
            login_process.terminate()
            login_process.wait(timeout=5)
            print("[INFO] Subprocess terminated.")
        except Exception as e:
            print(f"[WARN] Failed to terminate subprocess: {e}")

    sys.exit(0)


signal.signal(signal.SIGINT, cleanup)
signal.signal(signal.SIGTERM, cleanup)


def get_credentials_from_endpoint():
    """
    Get credentials from FastAPI endpoint.

    Reads auth token from ~/.cache/rhotp/auth_token and uses it for authentication.
    """
    creds_url = "http://localhost:8009/get_creds?context=associate&headless=false"

    # Read auth token from cache
    token_file = os.path.expanduser("~/.cache/rhotp/auth_token")
    try:
        with open(token_file, 'r') as f:
            auth_token = f.read().strip()
    except FileNotFoundError:
        print(f"Error: Auth token file not found at {token_file}")
        print("Make sure the RHOTP service has been started at least once.")
        return None, None
    except Exception as e:
        print(f"Error reading auth token: {e}")
        return None, None

    # Make authenticated API request
    try:
        headers = {
            'Authorization': f'Bearer {auth_token}'
        }
        response = requests.get(creds_url, headers=headers, timeout=5)
        response.raise_for_status()
        creds = response.text.strip().split('"')
        username, password = creds[1].split(",")
        return username.strip(), password.strip()
    except requests.RequestException as e:
        print(f"Error fetching credentials from API: {e}")
        return None, None


def ensure_chromedriver_matches():
    try:
        output = subprocess.check_output([chrome_binary, "--version"], text=True)
        match = re.search(r'(\d+\.\d+\.\d+\.\d+)', output)
        if not match:
            print("[ERROR] Could not parse Chrome version.")
            return
        chrome_version = match.group(1)
        chrome_major = chrome_version.split('.')[0]
    except Exception as e:
        print(f"[ERROR] Failed to get Chrome version: {e}")
        return

    try:
        output = subprocess.check_output([chrome_driver_location, '--version'], text=True)
        driver_version = re.search(r'(\d+)\.', output).group(1)
        if driver_version == chrome_major:
            return
        print(f"[INFO] ChromeDriver version mismatch: {driver_version} vs Chrome {chrome_major}")
    except Exception:
        print("[INFO] ChromeDriver not found or broken, will install fresh.")

    url = f"https://storage.googleapis.com/chrome-for-testing-public/{chrome_version}/linux64/chromedriver-linux64.zip"
    zip_path = os.path.join(chrome_driver_dir, "chromedriver.zip")
    os.makedirs(chrome_driver_dir, exist_ok=True)

    try:
        print(f"[INFO] Downloading ChromeDriver {chrome_version} from {url}")
        urllib.request.urlretrieve(url, zip_path)
        with zipfile.ZipFile(zip_path, "r") as zip_ref:
            zip_ref.extractall(chrome_driver_dir)

        extracted_path = os.path.join(chrome_driver_dir, "chromedriver-linux64", "chromedriver")
        shutil.move(extracted_path, chrome_driver_location)
        shutil.rmtree(os.path.join(chrome_driver_dir, "chromedriver-linux64"))
        os.chmod(chrome_driver_location, os.stat(chrome_driver_location).st_mode | stat.S_IEXEC)
        os.remove(zip_path)
        print(f"[INFO] ChromeDriver installed at {chrome_driver_location}")
    except Exception as e:
        print(f"[ERROR] Failed to download and install ChromeDriver: {e}")


def load_config():
    """Load configuration from rhtoken.json file."""
    global config, chrome_driver_dir, chrome_driver_location, profile_location, chrome_binary

    config_path = os.path.join(script_dir, "rhtoken.json")
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)

            # Expand ~ in paths
            chrome_config = config.get('chrome', {})
            chrome_driver_dir = os.path.expanduser(chrome_config.get('driver_dir', '~/bin'))
            chrome_driver_location = os.path.expanduser(chrome_config.get('driver_location', '~/bin/chromedriver'))
            profile_location = os.path.expanduser(chrome_config.get('profile_location', '~/.config/google-chrome-beta/Profile 1'))
            chrome_binary = chrome_config.get('binary_location', '/opt/google/chrome-beta/google-chrome-beta')

            return config
    except FileNotFoundError:
        print(f"[ERROR] Config file not found: {config_path}")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"[ERROR] Invalid JSON in config: {e}")
        sys.exit(1)


def wait_until_found(find_func, interval=0.5, timeout=30):
    start = time.time()
    while time.time() - start < timeout:
        try:
            result = find_func()
            if result:
                return result
        except Exception:
            pass
        time.sleep(interval)
    raise TimeoutError("Element not found in time.")


def get_token_string():
    global driver, login_process

    my_parser = argparse.ArgumentParser(description='Login to Red Hat OSD')
    my_parser.add_argument('env', metavar='env', type=str, help='The environment to get a token')
    my_parser.add_argument('-hl', '--headless', action='store_true', help='Run Selenium in headless mode')
    my_parser.add_argument('-q', '--query', action='store_true', help='Return the oc login command without executing it')
    args = my_parser.parse_args()

    # Load configuration from rhtoken.json
    config_data = load_config()
    clusters = config_data.get('clusters', {})

    # Get cluster configuration
    cluster = clusters.get(args.env)
    if not cluster:
        print(f"Error: Invalid environment '{args.env}' specified.")
        print(f"Available environments: {', '.join(clusters.keys())}")
        return

    url = cluster.get('url')
    if not url:
        print(f"Error: No URL configured for environment '{args.env}'")
        return

    ensure_chromedriver_matches()

    options = Options()
    options.binary_location = chrome_binary
    options.add_argument("--user-data-dir=" + profile_location)
    if args.headless:
        options.add_argument('--headless')
    service = Service(chrome_driver_location)

    driver = webdriver.Chrome(service=service, options=options)

    try:
        driver.get(url)

        wait = WebDriverWait(driver, 20)
        wait.until(lambda driver: driver.current_url != url)

        link = driver.find_element(By.XPATH, '//a')
        link.click()

        username, password = get_credentials_from_endpoint()

        if not username or not password:
            print("Error: Username or password could not be retrieved.")
            cleanup()

        try:
            username_input = WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.ID, "username"))
            )
            password_input = driver.find_element(By.ID, "password")
            submit_button = driver.find_element(By.ID, "submit")

            username_input.send_keys(username)
            password_input.send_keys(password)
            submit_button.click()

            WebDriverWait(driver, 10).until(lambda driver: driver.current_url != url)

        except Exception:
            print("Login form not detected, proceeding...")

        Button = wait_until_found(lambda: driver.find_element(By.XPATH, '//button'))
        Button.click()

        # Get the command from the page
        Pre = wait_until_found(lambda: driver.find_element(By.XPATH, '//pre').text)
        Pre = Pre.replace("('", "").replace("')", "").replace("'", "").replace("\n", "")

        # If query mode, just return the command and exit
        if args.query:
            print(Pre)
            return Pre

        parts = shlex.split(Pre)

        # Copy current environment
        env = os.environ.copy()

        # Optionally override KUBECONFIG if set in parent environment
        kubeconfig = os.environ.get("KUBECONFIG")
        if kubeconfig:
            env["KUBECONFIG"] = kubeconfig

        # print("rhtoken: " + "\n".join(env))

        # Launch subprocess with optional custom env
        login_process = subprocess.Popen(
            parts,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=env,  # ðŸ‘ˆ this is what applies the KUBECONFIG
            start_new_session=True,
        )

        try:
            stdout, _ = login_process.communicate(timeout=10)
        except subprocess.TimeoutExpired:
            login_process.kill()
            stdout, _ = login_process.communicate()

        print(Pre)
        print(stdout.decode("UTF-8"))

    except KeyboardInterrupt:
        print("\n[INFO] CTRL+C detected. Cleaning up...")
        cleanup()
    except Exception as e:
        print(f"[ERROR] Unexpected error: {e}")
        cleanup()
    finally:
        cleanup()


if __name__ == "__main__":
    get_token_string()
